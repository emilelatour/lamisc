% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/safe_ifelse.R
\name{safe_ifelse}
\alias{safe_ifelse}
\title{Preserves class when using ifelse}
\usage{
safe_ifelse(cond, true, false)
}
\arguments{
\item{cond}{A logical condition}

\item{true, false}{Values to use for \code{TRUE} and \code{FALSE} values of \code{cond}.
Attributes are taken from \code{true}.}
}
\value{
Where \code{cond} is \code{TRUE}, the matching value from
\code{true}, where it's \code{FALSE}, the matching value from \code{false}
}
\description{
This is just a cool, fun little function that I found on Stack Overflow,
\url{https://stackoverflow.com/questions/6668963/how-to-prevent-ifelse-from-turning-date-objects-into-numeric-objects}.
Note that the function \code{dplyr::if_else()} is probably a better way to do
the same thing since it is unit-tested and dcoumented in a CRAN package. Just
preserving this here.
}
\examples{
dates <- as.Date(c("2011-01-01",
                   "2011-01-02",
                   "2011-01-03",
                   "2011-01-04",
                   "2011-01-05"))

# This shows the issue with regular ifelse
dates <- ifelse(dates == "2011-01-01", dates - 1, dates)
dates
class(dates)

# Try out safe_ifelse
dates <- safe_ifelse(dates == "2011-01-01", dates - 1, dates)
dates
class(dates)
}
