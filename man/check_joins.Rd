% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/check-joins.R
\name{check_joins}
\alias{check_joins}
\title{Check the counts before and after join}
\usage{
check_joins(x, y, by = NULL)
}
\arguments{
\item{x, y}{A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See \emph{Methods}, below, for
more details.}

\item{by}{A join specification created with \code{\link[dplyr:join_by]{dplyr::join_by()}}, or a character
vector of variables to join by.

If \code{NULL}, the default, \verb{*_join()} will perform a natural join, using all
variables in common across \code{x} and \code{y}. A message lists the variables so
that you can check they're correct; suppress the message by supplying \code{by}
explicitly.

To join on different variables between \code{x} and \code{y}, use a \code{\link[dplyr:join_by]{dplyr::join_by()}}
specification. For example, \code{join_by(a == b)} will match \code{x$a} to \code{y$b}.

To join by multiple variables, use a \code{\link[dplyr:join_by]{dplyr::join_by()}} specification with
multiple expressions. For example, \code{join_by(a == b, c == d)} will match
\code{x$a} to \code{y$b} and \code{x$c} to \code{y$d}. If the column names are the same between
\code{x} and \code{y}, you can shorten this by listing only the variable names, like
\code{join_by(a, c)}.

\code{\link[dplyr:join_by]{dplyr::join_by()}} can also be used to perform inequality, rolling, and overlap
joins. See the documentation at
\code{\link[dplyr:join_by]{dplyr::join_by()}} for details on these types of
joins.

For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, \code{by = c("a", "b")} joins \code{x$a}
to \code{y$a} and \code{x$b} to \code{y$b}. If variable names differ between \code{x} and \code{y},
use a named character vector like \code{by = c("x_a" = "y_a", "x_b" = "y_b")}.}
}
\value{
A tibble.
}
\description{
Before and after using joins, it's important to check the counts of the data
sets. This funtions give you the counts for the data you intend to join and
the resulting counts for all forms of joins (e.g. left, right, inner, semi,
anti, full).
\subsection{Inner join}{

An \code{inner_join()} only keeps observations from \code{x} that have a matching key
in \code{y}.

The most important property of an inner join is that unmatched rows in either
input are not included in the result. This means that generally inner joins
are not appropriate in most analyses, because it is too easy to lose
observations.
}

\subsection{Outer joins}{

The three outer joins keep observations that appear in at least one of the
data frames:
\itemize{
\item A \code{left_join()} keeps all observations in \code{x}.
\item A \code{right_join()} keeps all observations in \code{y}.
\item A \code{full_join()} keeps all observations in \code{x} and \code{y}.
}
}

\subsection{Filtering joins}{
\itemize{
\item \code{semi_join()} return all rows from \code{x} with a match in \code{y}.
\item \code{anti_join()} return all rows from \code{x} with\strong{out} a match in \code{y}.
}
}
}
\examples{
library(dplyr)

check_joins(x = band_members,
            y = band_instruments,
            by = "name")

check_joins(x = band_members,
            y = band_instruments,
            by = join_by(name))


band_members <- band_members |>
  mutate(name.x = name,
         name.a = name)

band_instruments <- band_instruments |>
  mutate(name.y = name,
         name.b = name)

check_joins(x = band_members,
            y = band_instruments,
            by = c("name.x" = "name.y"))

check_joins(x = band_members,
            y = band_instruments,
            by = c("name.x" = "name.y",
                   "name.a" = "name.b"))
}
